#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RC->T->CSP
This codes is to simulate the terminal in the RSOPM-AKA scheme,
including chameleon hash function, zero knowledge proof for authentication, and key agreement

2021/5/14
Jerry
"""

import sslcrypto
import random
import pickle
import socket
import hashlib
import time
from Cyptology import ChameleonHash_ECC, key_type_transform
from sslcrypto.fallback._util import  bytes_to_int, int_to_bytes
from Cryptodome.PublicKey import ECC

print('-----------------------------------------Terminal registration phase-----------------------------------------------')
ChameleonHash = ChameleonHash_ECC.ChameleonHash()  # 实例化对象，这一步注意不可少！！！
KeyTrans = key_type_transform.KeyTrans()
order = ChameleonHash.order()

ID_i = b'123456789abcdef'
C_i = random.randint(1, order - 1)   #here C_i is m_i
r_i = random.randint(1, order - 1)   # here is to simulate R=PUF(C)
CH_i = ChameleonHash.Compute_CH(C_i, r_i)
print("The chameleon hash computed by terminal is ", CH_i.CH())
reg_message = {'C_i': C_i, 'ID_i': ID_i, 'CH_i': CH_i.CH()}
b_reg_message = pickle.dumps(reg_message)

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(('127.0.0.1', 9999))
s.sendto(b_reg_message, ('127.0.0.1', 12345))
data, addr = s.recvfrom(4096)
reg_comfirm = pickle.loads(data)
TXID_ri = reg_comfirm['TXID_ri']
print("The transaction ID received by terminal is ", TXID_ri)
print("-------------------------------------------Terminal registration finished！-----------------------------------------------")

print('--------------------------------------------AKA phase of Terminal-----------------------------------------------')
theta = random.randint(1, order - 1) # a random numberθ
TS_i = time.process_time()
Y_i = ChameleonHash.get_Y()
H0 = [ID_i, TS_i]
b_H0 = pickle.dumps(H0)
# PID_i = hash(b_H0)
h = hashlib.sha3_256()
h.update(b_H0)
PID_i = bytes_to_int(bytes(h.hexdigest(), encoding='utf-8'))
A_i = Y_i.pointQ.__mul__(theta)
H2 = [C_i, PID_i, A_i.xy, TS_i]
# print("H2 generated by terminal is ", H2)
b_H2 = pickle.dumps(H2)
# z_i = hash(b_H2)
# z_i = bytes_to_int(b_z_i)
k = hashlib.sha3_256()
k.update(b_H2)
z_i = bytes_to_int(bytes(k.hexdigest(), encoding='utf-8'))
# print("z_i: ", z_i)
# print(type(z_i))
r_i = theta * z_i

k_i = CH_i.trapdoor()[0]
x_i = CH_i.trapdoor()[1]

m_i = (k_i - r_i * x_i + order) % order

M_1 = {'PID_i': PID_i, 'm_i': m_i, 'A_i': A_i.xy, 'TS_i': TS_i, 'TXID_ri': TXID_ri}
b_M_1 = pickle.dumps(M_1)
s.sendto(b_M_1, ('127.0.0.1', 12341))
print('Terminal gernerate M_1 is ', M_1)

data_M_2, addr_M_2 = s.recvfrom(4096)
M_2 = pickle.loads(data_M_2)
print("Terminal received M2 is ", M_2)

# Blockchain query
CH_j = reg_comfirm['CH_j']
print("The chameleon hash CH_j queried from blockchain by Terminal is ", CH_j)

B_j_xy = M_2['B_j']
x = B_j_xy[0]
y = B_j_xy[1]
B_j = ECC.EccPoint(x, y)
P = ECC._curves['P-256'].G
H3 = [PID_i, M_2['PID_j'], TS_i, M_2['TS_j'], B_j.__mul__(x_i * theta).xy]
b_H3 = pickle.dumps(H3)
sk = hashlib.sha3_256()
sk.update(b_H3)
SK_ij = bytes_to_int(bytes(sk.hexdigest(), encoding='utf-8'))

H2_i = [SK_ij, M_2['PID_j'], B_j_xy, M_2['TS_j']]
b_H2_i = pickle.dumps(H2_i)
s = hashlib.sha3_256()
s.update(b_H2_i)
z_j = bytes_to_int(bytes(s.hexdigest(), encoding='utf-8'))
m_j = M_2['m_j']
CH_j_T = P.__mul__(m_j) + B_j.__mul__(z_j)
print("The chameleon hash CH_j_T computed by Terminal is ", CH_j_T.xy)
print("T_i authenticate CSP_j") if CH_j_T.xy == CH_j else print("CSP_j is illegal!!!")
print("-------------------------------------------Terminal AKA phase finished！------------------------------------------")
#  test
# P = ECC._curves['P-256'].G
# print('PID_i: ', PID_i)
# print("m_i: ", m_i)
# print("z_i: ", z_i)
# CH_i_CSP = P.__mul__(m_i) + A_i.__mul__(z_i)
# print('CH_i: ', CH_i.CH())
# print('CH_i_CSP: ', CH_i_CSP.xy)